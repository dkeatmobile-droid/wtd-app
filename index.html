<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="theme-color" content="#0b1220" />
  <title>WTD Tracker</title>
  <link rel="manifest" href="manifest.webmanifest" />
  <style>
    :root{
      --bg:#070b14;
      --panel:#0b1220;
      --panel2:#0e1830;
      --line:#1a2a4d;
      --text:#eaf1ff;
      --muted:#a9b7d6;
      --good:#2dd4bf;
      --warn:#fbbf24;
      --bad:#fb7185;
      --btn:#14254a;
      --btn2:#0f1e3c;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
    }
    *{box-sizing:border-box}
    body{margin:0;background:radial-gradient(1200px 900px at 20% -10%, #12224a 0%, var(--bg) 50%);color:var(--text)}
    header{
      position:sticky;top:0;z-index:10;
      background:linear-gradient(180deg, rgba(7,11,20,.98) 0%, rgba(7,11,20,.86) 100%);
      backdrop-filter: blur(10px);
      border-bottom:1px solid rgba(255,255,255,.06);
    }
    .wrap{max-width:960px;margin:0 auto;padding:14px 14px 100px}
    .topbar{display:flex;gap:12px;align-items:center;justify-content:space-between}
    .title{display:flex;flex-direction:column;gap:2px}
    .title h1{margin:0;font-size:16px;letter-spacing:.2px}
    .title .sub{font-size:12px;color:var(--muted)}
    .pill{
      display:inline-flex;align-items:center;gap:8px;
      padding:8px 10px;border:1px solid rgba(255,255,255,.08);
      border-radius:999px;background:rgba(11,18,32,.75);
      box-shadow: var(--shadow);
      font-size:12px;color:var(--muted);
      white-space:nowrap;
    }
    .dot{width:10px;height:10px;border-radius:50%;background:#64748b}
    .dot.DRIVING{background:var(--good)}
    .dot.OTHER{background:#60a5fa}
    .dot.POA{background:var(--warn)}
    .dot.BREAK{background:var(--bad)}
    main{padding-top:14px}
    .grid{display:grid;gap:12px}
    .cards{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:12px}
    @media(min-width:900px){.cards{grid-template-columns:repeat(4,minmax(0,1fr))}}
    .card{
      background:linear-gradient(180deg, rgba(14,24,48,.95) 0%, rgba(11,18,32,.9) 100%);
      border:1px solid rgba(255,255,255,.08);
      border-radius:16px;padding:12px;
      box-shadow: var(--shadow);
    }
    .card h3{margin:0 0 8px;font-size:12px;color:var(--muted);font-weight:700}
    .big{font-size:22px;font-weight:900;letter-spacing:.3px}
    .big2{font-size:28px;font-weight:950;letter-spacing:.4px}
    .muted{font-size:12px;color:var(--muted)}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    .btn{
      flex:1 1 130px;
      padding:12px 12px;border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background:linear-gradient(180deg, rgba(20,37,74,.95), rgba(15,30,60,.95));
      color:var(--text);
      font-weight:900;font-size:14px;
      letter-spacing:.2px;
      box-shadow: 0 10px 25px rgba(0,0,0,.30);
      user-select:none;
    }
    .btn:active{transform: translateY(1px)}
    .btn.secondary{background:linear-gradient(180deg, rgba(15,30,60,.85), rgba(12,22,44,.9))}
    .btn.mode{flex:1 1 140px}
    .btn.mode.DRIVING{outline:2px solid rgba(45,212,191,.35)}
    .btn.mode.OTHER{outline:2px solid rgba(96,165,250,.35)}
    .btn.mode.POA{outline:2px solid rgba(251,191,36,.35)}
    .btn.mode.BREAK{outline:2px solid rgba(251,113,133,.35)}
    .banner{
      display:flex;align-items:center;justify-content:space-between;
      gap:12px;padding:12px;border-radius:16px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(11,18,32,.55);
    }
    .banner strong{font-size:12px}
    .statusGood{color:var(--good)}
    .statusWarn{color:var(--warn)}
    .statusBad{color:var(--bad)}
    table{width:100%;border-collapse:collapse}
    th,td{padding:10px 8px;border-bottom:1px solid rgba(255,255,255,.08);font-size:12px}
    th{color:var(--muted);text-align:left;font-weight:800}
    td{color:var(--text)}
    .right{text-align:right}
    .footer{
      position:fixed;left:0;right:0;bottom:0;z-index:20;
      background:linear-gradient(180deg, rgba(7,11,20,.00) 0%, rgba(7,11,20,.92) 25%, rgba(7,11,20,.98) 100%);
      padding:12px 12px 14px;border-top:1px solid rgba(255,255,255,.06);
      backdrop-filter: blur(10px);
    }
    .footer .row{max-width:960px;margin:0 auto}
    .smallNote{font-size:11px;color:var(--muted);margin-top:8px;line-height:1.35}
    .chip{
      display:inline-flex;align-items:center;gap:6px;
      padding:6px 10px;border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(7,11,20,.35);
      font-size:12px;color:var(--muted);
    }
  </style>
</head>
<body>
<header>
  <div class="wrap" style="padding-bottom:12px">
    <div class="topbar">
      <div class="title">
        <h1>WTD Tracker</h1>
        <div class="sub">Working time, qualifying breaks (≥15m), and 6-hour interrupt countdown</div>
      </div>
      <div class="pill" id="modePill"><span class="dot" id="modeDot"></span><span id="modeText">Not started</span></div>
    </div>
    <div style="margin-top:10px;display:flex;gap:10px;flex-wrap:wrap">
      <span class="chip" id="dayChip"></span>
      <span class="chip">Saved on device</span>
      <span class="chip" id="shiftChip">Shift: —</span>
    </div>
  </div>
</header>

<div class="wrap">
  <main class="grid">

    <div class="card">
      <h3>Quick controls</h3>
      <div class="row">
        <button class="btn" id="btnStart">Start shift</button>
        <button class="btn secondary" id="btnEnd">End shift</button>
        <button class="btn secondary" id="btnReset">Reset day</button>
      </div>
      <div class="smallNote">
        Tap your mode whenever it changes. The app timestamps segments and totals everything automatically.
      </div>
    </div>

    <div class="card">
      <h3>Mode</h3>
      <div class="row">
        <button class="btn mode DRIVING" id="btnDriving">Driving</button>
        <button class="btn mode OTHER" id="btnOther">Other Work</button>
        <button class="btn mode POA" id="btnPOA">POA</button>
        <button class="btn mode BREAK" id="btnBreak">Break</button>
      </div>
      <div class="smallNote">
        Only <b>Driving</b> + <b>Other Work</b> counts as WTD working time. <b>Break</b> resets the 6-hour clock only if it’s <b>≥15 minutes</b>.
      </div>
    </div>

    <div class="banner" id="statusBanner">
      <div>
        <strong>Status:</strong>
        <span id="statusText" class="statusGood">Ready</span>
        <div class="muted" id="statusDetail">Start a shift to begin tracking.</div>
      </div>
      <div style="text-align:right">
        <div class="muted">Continuous working since last qualifying break</div>
        <div class="big" id="contWork">00:00</div>
      </div>
    </div>

    <div class="cards">
      <div class="card">
        <h3>Working time (WTD)</h3>
        <div class="big2" id="workTotal">00:00</div>
        <div class="muted">Driving + Other Work</div>
      </div>
      <div class="card">
        <h3>Qualifying breaks</h3>
        <div class="big2" id="qBreakTotal">00:00</div>
        <div class="muted">Break blocks ≥ 15 min</div>
      </div>
      <div class="card">
        <h3>Total break time</h3>
        <div class="big2" id="allBreakTotal">00:00</div>
        <div class="muted">All break segments (incl. <15m)</div>
      </div>
      <div class="card">
        <h3>POA</h3>
        <div class="big2" id="poaTotal">00:00</div>
        <div class="muted">Not working time</div>
      </div>
    </div>

    <div class="cards">
      <div class="card">
        <h3>6-hour interrupt countdown</h3>
        <div class="big2" id="interruptCountdown">—</div>
        <div class="muted" id="interruptNote">Take ≥15 min qualifying break by 6:00 continuous working.</div>
      </div>
      <div class="card">
        <h3>Interrupt due at</h3>
        <div class="big2" id="interruptDueAt">—</div>
        <div class="muted">Based on working time since last qualifying break.</div>
      </div>
      <div class="card">
        <h3>Total breaks required</h3>
        <div class="big2" id="breakRequired">00:00</div>
        <div class="muted" id="breakRule">0 / 30 / 45 depending on total working time.</div>
      </div>
      <div class="card">
        <h3>Break still needed</h3>
        <div class="big2" id="breakNeeded">00:00</div>
        <div class="muted">Qualifying break minutes still required today.</div>
      </div>
    </div>

    <div class="card">
      <h3>Today’s log</h3>
      <div class="row" style="margin-bottom:10px">
        <button class="btn secondary" id="btnUndo">Undo last</button>
        <button class="btn secondary" id="btnExport">Export CSV</button>
        <button class="btn secondary" id="btnCloseSegment">Close segment</button>
      </div>
      <div class="muted" style="margin-bottom:10px">
        “Close segment” just ends the current segment at the current time (useful before exporting).
      </div>
      <div style="overflow:auto;border-radius:12px">
        <table>
          <thead>
            <tr>
              <th>From</th>
              <th>To</th>
              <th>Mode</th>
              <th class="right">Mins</th>
              <th class="right">Qualifies?</th>
            </tr>
          </thead>
          <tbody id="logBody"></tbody>
        </table>
      </div>
      <div class="smallNote">
        Qualifying break = a break segment of <b>15 minutes or longer</b>. Break segments shorter than 15 minutes are shown as non-qualifying.
      </div>
    </div>

  </main>
</div>

<div class="footer">
  <div class="row">
    <button class="btn mode BREAK" id="btnQuickBreak">Start break now</button>
    <button class="btn mode OTHER" id="btnQuickWork">Back to work</button>
  </div>
</div>

<script>
(() => {
  const STORAGE_KEY = "wtd_tracker_pwa_v2";
  const QUALIFY_BREAK_MIN = 15;
  const INTERRUPT_LIMIT_MIN = 360; // 6 hours

  const $ = (id) => document.getElementById(id);

  const fmtHM = (mins) => {
    mins = Math.max(0, Math.floor(mins));
    const h = Math.floor(mins / 60);
    const m = mins % 60;
    return String(h).padStart(2,"0") + ":" + String(m).padStart(2,"0");
  };

  const fmtTime = (ms) => {
    if (!ms) return "—";
    const d = new Date(ms);
    return d.toLocaleTimeString([], {hour:"2-digit", minute:"2-digit"});
  };

  const todayLabel = () => {
    const d = new Date();
    return d.toLocaleDateString([], {weekday:"short", year:"numeric", month:"short", day:"2-digit"});
  };

  const now = () => Date.now();

  // state: segments[] are closed segments. current is open segment.
  let state = {
    shiftStart: null,
    shiftEnd: null,
    currentMode: null,
    currentFrom: null,
    segments: [] // {mode, from, to}
  };

  const save = () => localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
  const load = () => {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return;
    try { state = JSON.parse(raw); } catch {}
  };

  const isWorkingMode = (m) => (m === "DRIVING" || m === "OTHER");
  const isBreakMode = (m) => (m === "BREAK");
  const isPOA = (m) => (m === "POA");

  const closeCurrent = (t = now()) => {
    if (!state.shiftStart || !state.currentMode || !state.currentFrom) return;
    if (t <= state.currentFrom) return;
    state.segments.push({ mode: state.currentMode, from: state.currentFrom, to: t });
    state.currentFrom = t;
    save();
  };

  const setMode = (mode) => {
    if (!state.shiftStart) return;
    const t = now();
    if (!state.currentMode) {
      state.currentMode = mode;
      state.currentFrom = t;
      save();
      render();
      return;
    }
    closeCurrent(t);
    state.currentMode = mode;
    save();
    render();
  };

  const startShift = () => {
    const t = now();
    state.shiftStart = t;
    state.shiftEnd = null;
    state.currentMode = "OTHER";
    state.currentFrom = t;
    state.segments = [];
    save();
    render();
  };

  const endShift = () => {
    if (!state.shiftStart) return;
    const t = now();
    closeCurrent(t);
    state.shiftEnd = t;
    state.currentMode = null;
    state.currentFrom = null;
    save();
    render();
  };

  const resetDay = () => {
    state = { shiftStart:null, shiftEnd:null, currentMode:null, currentFrom:null, segments:[] };
    save();
    render();
  };

  const undoLast = () => {
    if (!state.segments.length) return;
    state.segments.pop();
    save();
    render();
  };

  const getAllSegmentsIncludingOpen = () => {
    const out = [...state.segments];
    if (state.shiftStart && state.currentMode && state.currentFrom) {
      out.push({ mode: state.currentMode, from: state.currentFrom, to: now(), open:true });
    }
    return out;
  };

  const minutesBetween = (a,b) => Math.max(0, Math.floor((b - a) / 60000));

  // Compute totals + continuous working since last qualifying break (>=15m BREAK)
  const compute = () => {
    const segs = getAllSegmentsIncludingOpen();

    let workMin = 0;
    let poaMin = 0;
    let breakAllMin = 0;
    let breakQualMin = 0;

    // continuous working clock: counts only working modes, resets only by qualifying breaks
    let contWorkMin = 0;

    for (const s of segs) {
      const m = minutesBetween(s.from, s.to);
      if (isWorkingMode(s.mode)) {
        workMin += m;
        contWorkMin += m;
      } else if (isPOA(s.mode)) {
        poaMin += m;
        // POA does not count as working time, but it also does not “reset” the 6h working clock
        // (it’s not a break). So contWorkMin unchanged.
      } else if (isBreakMode(s.mode)) {
        breakAllMin += m;
        if (m >= QUALIFY_BREAK_MIN) {
          breakQualMin += m;
          contWorkMin = 0; // qualifying break interrupts work
        } else {
          // non-qualifying break does not reset continuous working clock
        }
      }
    }

    // Total break requirement (qualifying breaks only)
    let requiredMin = 0;
    if (workMin > 540) requiredMin = 45;
    else if (workMin > 360) requiredMin = 30;
    else requiredMin = 0;

    const neededMin = Math.max(0, requiredMin - breakQualMin);

    // Interrupt due time: 6h continuous working since last qualifying break
    // Find the timestamp when contWork reaches 360 since the last qualifying break.
    // We'll approximate by backtracking from now across segments until we accumulate contWorkMin.
    let dueAt = null;
    if (state.shiftStart) {
      if (contWorkMin >= INTERRUPT_LIMIT_MIN) {
        dueAt = now(); // already due
      } else {
        // compute when it will be due if you continue working without a qualifying break:
        const remaining = INTERRUPT_LIMIT_MIN - contWorkMin;
        dueAt = now() + remaining * 60000;
      }
    }

    return { segs, workMin, poaMin, breakAllMin, breakQualMin, contWorkMin, requiredMin, neededMin, dueAt };
  };

  const render = () => {
    $("dayChip").textContent = todayLabel();

    // Mode pill
    if (!state.shiftStart) {
      $("modeText").textContent = "Not started";
      $("modeDot").className = "dot";
      $("shiftChip").textContent = "Shift: —";
    } else if (state.shiftEnd) {
      $("modeText").textContent = "Ended";
      $("modeDot").className = "dot";
      $("shiftChip").textContent = `Shift: ${fmtTime(state.shiftStart)}–${fmtTime(state.shiftEnd)}`;
    } else {
      $("modeText").textContent = state.currentMode || "—";
      $("modeDot").className = "dot " + (state.currentMode || "");
      $("shiftChip").textContent = `Shift: ${fmtTime(state.shiftStart)}–…`;
    }

    const c = compute();

    $("workTotal").textContent = fmtHM(c.workMin);
    $("poaTotal").textContent = fmtHM(c.poaMin);
    $("allBreakTotal").textContent = fmtHM(c.breakAllMin);
    $("qBreakTotal").textContent = fmtHM(c.breakQualMin);

    $("contWork").textContent = fmtHM(c.contWorkMin);

    $("breakRequired").textContent = fmtHM(c.requiredMin);
    $("breakNeeded").textContent = fmtHM(c.neededMin);

    // Interrupt countdown + due-at
    if (!state.shiftStart || state.shiftEnd) {
      $("interruptCountdown").textContent = "—";
      $("interruptDueAt").textContent = "—";
      $("interruptNote").textContent = "Start a shift to see the 6-hour interrupt countdown.";
    } else {
      const remaining = Math.max(0, INTERRUPT_LIMIT_MIN - c.contWorkMin);
      $("interruptCountdown").textContent = remaining === 0 ? "DUE NOW" : fmtHM(remaining);
      $("interruptDueAt").textContent = fmtTime(c.dueAt);
      $("interruptNote").textContent = "Take ≥15 min qualifying break by 6:00 continuous working time.";
    }

    // Status banner
    const banner = $("statusText");
    const detail = $("statusDetail");

    if (!state.shiftStart) {
      banner.textContent = "Ready";
      banner.className = "statusGood";
      detail.textContent = "Start a shift to begin tracking.";
    } else if (state.shiftEnd) {
      banner.textContent = "Shift ended";
      banner.className = "statusGood";
      detail.textContent = "Export CSV if you want a record.";
    } else {
      const interruptDue = c.contWorkMin >= INTERRUPT_LIMIT_MIN;
      const totalBreakShort = c.neededMin > 0 && (c.workMin > 360); // only meaningful once past 6h
      if (interruptDue) {
        banner.textContent = "Break required now (≥15m)";
        banner.className = "statusBad";
        detail.textContent = "You’ve hit 6:00 continuous working time since last qualifying break.";
      } else if (c.contWorkMin >= 330) {
        banner.textContent = "Break soon";
        banner.className = "statusWarn";
        detail.textContent = "Approaching 6:00 continuous working time. Plan a ≥15m break.";
      } else if (totalBreakShort) {
        banner.textContent = "More qualifying breaks needed";
        banner.className = "statusWarn";
        detail.textContent = "Your total qualifying breaks are below today’s requirement so far.";
      } else {
        banner.textContent = "Compliant so far";
        banner.className = "statusGood";
        detail.textContent = "Keep tracking mode changes; qualifying breaks are ≥15 minutes.";
      }
    }

    // Log table
    const tbody = $("logBody");
    tbody.innerHTML = "";
    const closed = [...state.segments];
    // include open segment as last row (live)
    if (state.shiftStart && state.currentMode && state.currentFrom && !state.shiftEnd) {
      closed.push({ mode: state.currentMode, from: state.currentFrom, to: now(), open:true });
    }

    for (const s of closed) {
      const m = minutesBetween(s.from, s.to);
      const qualifies = (s.mode === "BREAK" && m >= QUALIFY_BREAK_MIN) ? "Yes" :
                        (s.mode === "BREAK") ? "No" : "—";

      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${fmtTime(s.from)}</td>
        <td>${s.open ? "…" : fmtTime(s.to)}</td>
        <td>${s.mode}</td>
        <td class="right">${m}</td>
        <td class="right">${qualifies}</td>
      `;
      tbody.appendChild(tr);
    }
  };

  const exportCSV = () => {
    const rows = [["from","to","mode","minutes","qualifying_break"]];
    const segs = [...state.segments];
    // close open segment for export clarity
    if (state.shiftStart && state.currentMode && state.currentFrom && !state.shiftEnd) {
      segs.push({ mode: state.currentMode, from: state.currentFrom, to: now() });
    }

    for (const s of segs) {
      const m = minutesBetween(s.from, s.to);
      const q = (s.mode === "BREAK" && m >= QUALIFY_BREAK_MIN) ? "yes" :
                (s.mode === "BREAK") ? "no" : "";
      rows.push([new Date(s.from).toISOString(), new Date(s.to).toISOString(), s.mode, String(m), q]);
    }

    const c = compute();
    rows.push([]);
    rows.push(["summary","","","", ""]);
    rows.push(["working_time_minutes", "", "", String(c.workMin), ""]);
    rows.push(["qualifying_break_minutes", "", "", String(c.breakQualMin), ""]);
    rows.push(["total_break_minutes", "", "", String(c.breakAllMin), ""]);
    rows.push(["poa_minutes", "", "", String(c.poaMin), ""]);
    rows.push(["break_required_minutes", "", "", String(c.requiredMin), ""]);
    rows.push(["break_needed_minutes", "", "", String(c.neededMin), ""]);

    const csv = rows.map(r => r.map(v => {
      const s = String(v ?? "");
      return /[",\n]/.test(s) ? `"${s.replaceAll('"','""')}"` : s;
    }).join(",")).join("\n");

    const blob = new Blob([csv], {type:"text/csv;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `wtd_${new Date().toISOString().slice(0,10)}.csv`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  };

  // Wire up buttons
  $("btnStart").addEventListener("click", startShift);
  $("btnEnd").addEventListener("click", endShift);
  $("btnReset").addEventListener("click", resetDay);

  $("btnDriving").addEventListener("click", () => setMode("DRIVING"));
  $("btnOther").addEventListener("click", () => setMode("OTHER"));
  $("btnPOA").addEventListener("click", () => setMode("POA"));
  $("btnBreak").addEventListener("click", () => setMode("BREAK"));

  $("btnQuickBreak").addEventListener("click", () => setMode("BREAK"));
  $("btnQuickWork").addEventListener("click", () => setMode("OTHER"));

  $("btnUndo").addEventListener("click", undoLast);
  $("btnExport").addEventListener("click", exportCSV);
  $("btnCloseSegment").addEventListener("click", () => { closeCurrent(now()); render(); });

  // PWA service worker
  if ("serviceWorker" in navigator) {
    navigator.serviceWorker.register("./sw.js").catch(()=>{});
  }

  load();
  render();
  setInterval(render, 5000);
})();
</script>
</body>
</html>
