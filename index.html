<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WTD Working Time Tracker</title>
    <style>
      :root {
        --bg: #f3f4f6;
        --card: #ffffff;
        --text: #0f172a;
        --muted: #6b7280;
        --shadow: 0 10px 25px rgba(0, 0, 0, 0.08);
        --radius: 22px;
        --pill: 999px;
        --border: rgba(15, 23, 42, 0.12);
      }

      * { box-sizing: border-box; }
      body {
        margin: 0;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
        background: var(--bg);
        color: var(--text);
      }

      .top {
        padding: 24px 20px 18px;
        background: radial-gradient(1200px 600px at 30% 10%, #2b3b58 0%, #0b1324 55%, #060a14 100%);
        color: #fff;
      }

      .top-row {
        display: flex;
        gap: 18px;
        align-items: center;
      }

      .lights {
        width: 76px;
        height: 170px;
        border-radius: 24px;
        background: rgba(0,0,0,0.55);
        padding: 10px;
        box-shadow: 0 20px 40px rgba(0,0,0,0.25) inset;
        display: grid;
        gap: 10px;
        flex: 0 0 auto;
      }
      .lamp {
        border-radius: 999px;
        background: rgba(255,255,255,0.12);
        position: relative;
        overflow: hidden;
      }
      .lamp::after{
        content:"";
        position:absolute;
        inset: 14% 18% auto auto;
        width: 55%;
        height: 35%;
        border-radius: 999px;
        background: rgba(255,255,255,0.20);
        transform: rotate(-20deg);
      }
      .lamp.on.green { background: rgba(16,185,129,0.75); box-shadow: 0 0 20px rgba(16,185,129,0.55); }
      .lamp.on.red   { background: rgba(239,68,68,0.75);   box-shadow: 0 0 20px rgba(239,68,68,0.55); }
      .lamp.on.amber { background: rgba(245,158,11,0.75);  box-shadow: 0 0 20px rgba(245,158,11,0.55); }

      .header {
        min-width: 0; /* IMPORTANT: allows wrapping inside flex */
        flex: 1 1 auto;
      }
      .title {
        font-size: 34px;
        line-height: 1.05;
        margin: 0 0 8px 0;
        font-weight: 800;
        letter-spacing: 0.3px;
      }

      /* IMPORTANT: FIXES "runs off the page" */
      .sub {
        margin: 0;
        font-size: 20px;
        color: rgba(255,255,255,0.85);
        line-height: 1.25;
        white-space: normal;
        overflow-wrap: anywhere;
        word-break: break-word;
      }
      .sub strong { color: #fff; }

      .subgrid {
        display: grid;
        gap: 6px;
        margin-top: 10px;
        font-size: 14px;
        color: rgba(255,255,255,0.7);
      }

      .container {
        max-width: 860px;
        margin: -18px auto 30px;
        padding: 0 16px;
      }

      .panel {
        background: rgba(255,255,255,0.6);
        border: 1px solid rgba(255,255,255,0.4);
        border-radius: 28px;
        padding: 16px;
        box-shadow: var(--shadow);
        backdrop-filter: blur(12px);
      }

      .row {
        display: flex;
        gap: 14px;
        flex-wrap: wrap;
      }

      .pill {
        border-radius: var(--pill);
        padding: 14px 18px;
        font-weight: 700;
        border: 1px solid var(--border);
        background: rgba(255,255,255,0.8);
        cursor: pointer;
        min-width: 170px;
        text-align: center;
      }
      .pill.primary { background: rgba(16,185,129,0.18); border-color: rgba(16,185,129,0.45); color: #065f46; }
      .pill.danger  { background: rgba(239,68,68,0.10); border-color: rgba(239,68,68,0.35); color: #991b1b; }

      .pill[disabled] {
        opacity: 0.55;
        cursor: not-allowed;
      }

      .grid {
        margin-top: 14px;
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 14px;
      }
      @media (max-width: 640px) {
        .grid { grid-template-columns: 1fr; }
        .pill { width: 100%; min-width: 0; }
      }

      .card {
        background: rgba(255,255,255,0.85);
        border: 1px solid rgba(15,23,42,0.08);
        border-radius: var(--radius);
        padding: 16px 18px;
        box-shadow: 0 8px 20px rgba(0,0,0,0.06);
      }

      .card h3 {
        margin: 0 0 10px 0;
        font-size: 22px;
        font-weight: 800;
      }

      .metric-label {
        margin: 0;
        color: var(--muted);
        font-weight: 700;
        letter-spacing: 0.2px;
      }
      .metric {
        margin: 6px 0 0 0;
        font-size: 44px;
        font-weight: 900;
        letter-spacing: 0.6px;
      }

      .mode-row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 14px;
        margin-top: 14px;
      }
      @media (max-width: 640px) { .mode-row { grid-template-columns: 1fr; } }

      .mode-btn {
        border-radius: var(--radius);
        padding: 18px 16px;
        font-size: 24px;
        font-weight: 900;
        border: 1px solid rgba(15,23,42,0.10);
        background: rgba(255,255,255,0.88);
        cursor: pointer;
      }
      .mode-btn.active.work { outline: 3px solid rgba(16,185,129,0.35); }
      .mode-btn.active.break { outline: 3px solid rgba(59,130,246,0.30); }
      .mode-btn[disabled] { opacity: 0.55; cursor: not-allowed; }

      .small {
        font-size: 13px;
        color: var(--muted);
        margin-top: 8px;
        line-height: 1.35;
      }

      .mono {
        font-variant-numeric: tabular-nums;
        font-feature-settings: "tnum" 1;
      }
    </style>
  </head>

  <body>
    <header class="top">
      <div class="top-row">
        <div class="lights" aria-label="status lights">
          <div class="lamp" id="lamp1"></div>
          <div class="lamp" id="lamp2"></div>
          <div class="lamp on green" id="lamp3"></div>
        </div>

        <div class="header">
          <h1 class="title">WTD Working<br />Time Tracker</h1>

          <!-- ✅ Wrap-safe line that will NOT run off the page -->
          <p class="sub" id="statusLine">
            <strong>Compliant</strong>: next break <span class="mono" id="nextBreakHeader">06:00</span>
          </p>

          <div class="subgrid">
            <div id="shiftSummary" class="mono">Start: --:-- · Finish: --:-- · Duration: 00:00</div>
            <div id="modeSummary">Mode: Idle</div>
          </div>
        </div>
      </div>
    </header>

    <main class="container">
      <section class="panel">
        <div class="row">
          <!-- ✅ This is now a label-style button, but we disable it (status indicator) -->
          <button class="pill primary" id="shiftStateBtn" disabled>Shift not running</button>

          <!-- ✅ End shift captures FINISH TIME -->
          <button class="pill" id="endShiftBtn" disabled>End shift</button>

          <!-- ✅ Reset clears day -->
          <button class="pill danger" id="resetBtn">Reset day</button>
        </div>

        <div class="grid">
          <div class="card">
            <h3>Work</h3>
            <p class="metric-label">Shift time</p>
            <p class="metric mono" id="shiftTime">00:00</p>

            <p class="metric-label">Next break in</p>
            <p class="metric mono" style="font-size: 38px" id="nextBreak">06:00</p>
          </div>

          <div class="card">
            <h3>Break</h3>
            <p class="metric-label">Continuous work</p>
            <p class="metric mono" id="continuousWork">00:00</p>

            <p class="metric-label">Break still needed</p>
            <p class="metric mono" style="font-size: 38px" id="breakStillNeeded">00:00</p>
          </div>
        </div>

        <div class="mode-row">
          <!-- ✅ Start shift does NOT auto-enter Work -->
          <button class="mode-btn" id="startShiftBtn">Start shift</button>

          <!-- ✅ These only work when shift is running -->
          <button class="mode-btn work" id="workBtn" disabled>Work</button>
          <button class="mode-btn break" id="breakBtn" disabled>Break</button>
        </div>

        <div class="small">
          ✅ Logic checks:
          <ul>
            <li>Start shift sets <span class="mono">shiftState=running</span> and <span class="mono">activityState=idle</span> (no auto-work).</li>
            <li>End shift stores finish time and freezes duration display.</li>
            <li>Header text wraps safely and will not overflow.</li>
          </ul>
        </div>
      </section>
    </main>

    <script>
      // ---------------------------
      // State (separated correctly)
      // ---------------------------
      const state = {
        shiftState: "off",       // "off" | "running" | "ended"
        activityState: "idle",   // "idle" | "work" | "break"
        shiftStart: null,        // Date
        shiftEnd: null,          // Date
        activityStart: null,     // Date
        continuousWorkStart: null, // Date (tracks uninterrupted work)
        totals: {
          workMs: 0,
          breakMs: 0,
        },
        // For demo: next break target (e.g., 6h from continuous work start)
        breakRuleMs: 6 * 60 * 60 * 1000,
      };

      // ---------------------------
      // Helpers
      // ---------------------------
      const pad2 = (n) => String(n).padStart(2, "0");

      function fmtTimeHM(d) {
        if (!d) return "--:--";
        return `${pad2(d.getHours())}:${pad2(d.getMinutes())}`;
      }

      function fmtDuration(ms) {
        ms = Math.max(0, ms);
        const totalSec = Math.floor(ms / 1000);
        const h = Math.floor(totalSec / 3600);
        const m = Math.floor((totalSec % 3600) / 60);
        return `${pad2(h)}:${pad2(m)}`;
      }

      function now() { return new Date(); }

      function shiftElapsedMs() {
        if (!state.shiftStart) return 0;
        const end = state.shiftEnd ?? now();
        return end - state.shiftStart;
      }

      function currentActivityElapsedMs() {
        if (!state.activityStart) return 0;
        return (state.shiftEnd ?? now()) - state.activityStart;
      }

      function continuousWorkMs() {
        if (state.shiftState !== "running") return 0;
        if (state.activityState !== "work") return 0;
        if (!state.continuousWorkStart) return 0;
        return now() - state.continuousWorkStart;
      }

      function nextBreakInMs() {
        // next break countdown based on continuous work
        const cw = continuousWorkMs();
        return Math.max(0, state.breakRuleMs - cw);
      }

      // ---------------------------
      // DOM
      // ---------------------------
      const el = {
        shiftStateBtn: document.getElementById("shiftStateBtn"),
        startShiftBtn: document.getElementById("startShiftBtn"),
        endShiftBtn: document.getElementById("endShiftBtn"),
        resetBtn: document.getElementById("resetBtn"),
        workBtn: document.getElementById("workBtn"),
        breakBtn: document.getElementById("breakBtn"),

        shiftTime: document.getElementById("shiftTime"),
        continuousWork: document.getElementById("continuousWork"),
        nextBreak: document.getElementById("nextBreak"),
        nextBreakHeader: document.getElementById("nextBreakHeader"),
        breakStillNeeded: document.getElementById("breakStillNeeded"),

        shiftSummary: document.getElementById("shiftSummary"),
        modeSummary: document.getElementById("modeSummary"),
        statusLine: document.getElementById("statusLine"),

        lamp1: document.getElementById("lamp1"),
        lamp2: document.getElementById("lamp2"),
        lamp3: document.getElementById("lamp3"),
      };

      // ---------------------------
      // Core transitions (checked)
      // ---------------------------
      function startShift() {
        if (state.shiftState === "running") return;

        state.shiftState = "running";
        state.activityState = "idle";  // ✅ critical: do NOT auto-switch to work
        state.shiftStart = now();
        state.shiftEnd = null;

        state.activityStart = null;
        state.continuousWorkStart = null;

        updateUI();
      }

      function endShift() {
        if (state.shiftState !== "running") return;

        // Close any active activity into totals
        closeCurrentActivity();

        state.shiftEnd = now();
        state.shiftState = "ended";
        state.activityState = "idle";
        state.activityStart = null;
        state.continuousWorkStart = null;

        updateUI();
      }

      function resetDay() {
        state.shiftState = "off";
        state.activityState = "idle";
        state.shiftStart = null;
        state.shiftEnd = null;
        state.activityStart = null;
        state.continuousWorkStart = null;
        state.totals.workMs = 0;
        state.totals.breakMs = 0;

        updateUI();
      }

      function setActivity(next) {
        if (state.shiftState !== "running") return;
        if (!["work", "break", "idle"].includes(next)) return;
        if (state.activityState === next) return;

        closeCurrentActivity();

        state.activityState = next;
        if (next === "idle") {
          state.activityStart = null;
          state.continuousWorkStart = null;
        } else {
          state.activityStart = now();
          if (next === "work") {
            // start/restart continuous work window
            state.continuousWorkStart = now();
          } else {
            state.continuousWorkStart = null;
          }
        }

        updateUI();
      }

      function closeCurrentActivity() {
        if (!state.activityStart) return;
        const ms = currentActivityElapsedMs();
        if (state.activityState === "work") state.totals.workMs += ms;
        if (state.activityState === "break") state.totals.breakMs += ms;
        state.activityStart = null;
      }

      // ---------------------------
      // UI
      // ---------------------------
      function updateUI() {
        // Buttons
        el.endShiftBtn.disabled = state.shiftState !== "running";
        el.workBtn.disabled = state.shiftState !== "running";
        el.breakBtn.disabled = state.shiftState !== "running";

        // Shift indicator (not tappable)
        if (state.shiftState === "running") {
          el.shiftStateBtn.textContent = "Shift running";
        } else if (state.shiftState === "ended") {
          el.shiftStateBtn.textContent = "Shift ended";
        } else {
          el.shiftStateBtn.textContent = "Shift not running";
        }

        // Mode buttons
        el.workBtn.classList.toggle("active", state.activityState === "work");
        el.workBtn.classList.toggle("work", true);

        el.breakBtn.classList.toggle("active", state.activityState === "break");
        el.breakBtn.classList.toggle("break", true);

        // Lamps (simple: green when compliant, amber near break, red overdue)
        el.lamp1.className = "lamp";
        el.lamp2.className = "lamp";
        el.lamp3.className = "lamp";

        let compliance = "Compliant";
        if (state.shiftState === "running" && state.activityState === "work") {
          const nb = nextBreakInMs();
          if (nb === 0) compliance = "Break due";
          else if (nb < 30 * 60 * 1000) compliance = "Break soon";
        }

        if (compliance === "Compliant") el.lamp3.classList.add("on", "green");
        if (compliance === "Break soon") el.lamp2.classList.add("on", "amber");
        if (compliance === "Break due") el.lamp1.classList.add("on", "red");

        // Metrics
        el.shiftTime.textContent = fmtDuration(shiftElapsedMs());

        const cw = continuousWorkMs();
        el.continuousWork.textContent = fmtDuration(cw);

        const nb = nextBreakInMs();
        const nbText = fmtDuration(nb);
        el.nextBreak.textContent = nbText;
        el.nextBreakHeader.textContent = nbText;

        // Break still needed (demo logic: if break due, show 00:30 required)
        let needed = 0;
        if (state.shiftState === "running" && state.activityState === "work" && nb === 0) {
          needed = 30 * 60 * 1000;
        }
        el.breakStillNeeded.textContent = fmtDuration(needed);

        // Header summaries (Start / Finish / Duration)
        const start = fmtTimeHM(state.shiftStart);
        const finish = fmtTimeHM(state.shiftEnd);
        const dur = fmtDuration(shiftElapsedMs());
        el.shiftSummary.textContent = `Start: ${start} · Finish: ${finish} · Duration: ${dur}`;

        el.modeSummary.textContent = `Mode: ${state.activityState[0].toUpperCase()}${state.activityState.slice(1)}`;

        // Wrap-safe status line text
        el.statusLine.innerHTML =
          `<strong>${compliance}</strong>: next break <span class="mono">${nbText}</span>`;
      }

      // ---------------------------
      // Events
      // ---------------------------
      el.startShiftBtn.addEventListener("click", () => startShift());
      el.endShiftBtn.addEventListener("click", () => endShift());
      el.resetBtn.addEventListener("click", () => resetDay());
      el.workBtn.addEventListener("click", () => setActivity("work"));
      el.breakBtn.addEventListener("click", () => setActivity("break"));

      // Tick updates (safe)
      setInterval(() => {
        if (state.shiftState === "running") updateUI();
      }, 1000);

      // Initial render
      updateUI();
    </script>
  </body>
</html>
